================================================================================
                        PUSH SWAP - EXPLICATION COMPLÃˆTE
================================================================================

================================================================================
1. LES DEUX STRUCTURES - POURQUOI ET COMMENT ?
================================================================================

ğŸ”— STRUCTURE t_node (UN MAILLON DE LA CHAÃNE)
----------------------------------------------
typedef struct s_node {
    int             value;          // La valeur stockÃ©e (ex: 42)
    int             index;          // Position dans le tri final
    int             cost;           // CoÃ»t pour dÃ©placer ce nÅ“ud
    int             target;         // Cible dans l'autre pile
    bool            above_median;   // Au-dessus de la mÃ©diane ?
    bool            cheapest;       // Le moins cher Ã  dÃ©placer ?
    struct s_node   *next;          // Pointeur vers le nÅ“ud suivant
    struct s_node   *prev;          // Pointeur vers le nÅ“ud prÃ©cÃ©dent
} t_node;

ğŸ“š STRUCTURE t_stack (LE GESTIONNAIRE DE PILE)
-----------------------------------------------
typedef struct s_stack {
    t_node  *top;       // Pointeur vers le PREMIER nÅ“ud (sommet)
    t_node  *bottom;    // Pointeur vers le DERNIER nÅ“ud (fond)
    int     size;       // Nombre total d'Ã©lÃ©ments
} t_stack;

================================================================================
2. SCHÃ‰MA VISUEL - COMMENT Ã‡A MARCHE ?
================================================================================

Exemple avec la pile A contenant [5, 3, 8] :

    t_stack A:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ top: â”€â”€â†’    â”‚ â”€â”€â”€â”€â”€â” (AccÃ¨s direct au premier Ã©lÃ©ment)
    â”‚ bottom: â”€â”€â†’ â”‚ â”€â”€â”  â”‚
    â”‚ size: 3     â”‚   â”‚  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
                      â”‚  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
         â”‚               â”‚
         â–¼               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ value: 5    â”‚      â”‚      â”‚ value: 3    â”‚      â”‚ value: 8    â”‚
    â”‚ prev: NULL  â”‚      â”‚      â”‚ prev: â†â”€â”€   â”‚      â”‚ prev: â†â”€â”€   â”‚
    â”‚ next: â”€â”€â†’   â”‚â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”€â”€â”€â†’â”‚ next: â”€â”€â†’   â”‚â”€â”€â”€â”€â”€â†’â”‚ next: NULL  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–² top                                              â–² bottom
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           (AccÃ¨s direct au dernier)

================================================================================
3. POURQUOI CETTE STRUCTURE DOUBLE ?
================================================================================

âŒ SANS t_stack (PROBLÃ‰MATIQUE) :
---------------------------------
t_node *pile = quelque_part_en_memoire;

Pour faire une opÃ©ration simple :
- Trouver le dÃ©but ? â†’ Parcourir toute la liste !
- ConnaÃ®tre la taille ? â†’ Compter tous les Ã©lÃ©ments !
- Ajouter Ã  la fin ? â†’ Parcourir jusqu'au bout !

âœ… AVEC t_stack (EFFICACE) :
----------------------------
t_stack a;

OpÃ©rations instantanÃ©es :
- Premier Ã©lÃ©ment : a.top->value          (O(1))
- Dernier Ã©lÃ©ment : a.bottom->value       (O(1))
- Taille : a.size                         (O(1))
- Ajouter au dÃ©but : modifier a.top       (O(1))
- Ajouter Ã  la fin : modifier a.bottom    (O(1))

================================================================================
4. OPÃ‰RATIONS VISUELLES
================================================================================

ğŸ”„ OPÃ‰RATION SA (SWAP A) :
--------------------------
AVANT:  top â†’ [5] â†’ [3] â†’ [8] â† bottom
APRÃˆS:  top â†’ [3] â†’ [5] â†’ [8] â† bottom
        â””â”€ Ã‰change des 2 premiers Ã©lÃ©ments

ğŸš€ OPÃ‰RATION PB (PUSH B) :
--------------------------
Pile A: top â†’ [5] â†’ [3] â†’ [8] â† bottom    Pile B: vide
                â†“
Pile A: top â†’ [3] â†’ [8] â† bottom          Pile B: top â†’ [5] â† bottom
        â””â”€ Le premier de A va au sommet de B

ğŸ”„ OPÃ‰RATION RA (ROTATE A) :
----------------------------
AVANT:  top â†’ [5] â†’ [3] â†’ [8] â† bottom
                    â†“ rotation vers le haut
APRÃˆS:  top â†’ [3] â†’ [8] â†’ [5] â† bottom
        â””â”€ Le premier devient le dernier

================================================================================
5. ALGORITHME PUSH_SWAP - VUE D'ENSEMBLE
================================================================================

ğŸ¯ STRATÃ‰GIE GÃ‰NÃ‰RALE :
-----------------------
1. Si â‰¤ 5 Ã©lÃ©ments â†’ Algorithmes optimisÃ©s spÃ©cialisÃ©s
2. Si > 5 Ã©lÃ©ments â†’ Algorithme par chunks (Turk method)

================================================================================
6. ALGORITHME PETITES LISTES (â‰¤ 5 Ã©lÃ©ments)
================================================================================

ğŸ“Š CAS SPÃ‰CIAUX OPTIMISÃ‰S :

2 Ã‰LÃ‰MENTS :
-----------
[2, 1] â†’ sa â†’ [1, 2] âœ…

3 Ã‰LÃ‰MENTS :
-----------
Toutes les combinaisons sont hardcodÃ©es :
[3, 2, 1] â†’ sa + rra â†’ [1, 2, 3] âœ…
[2, 3, 1] â†’ rra â†’ [1, 2, 3] âœ…
etc.

4-5 Ã‰LÃ‰MENTS :
-------------
1. Trouver le(s) plus petit(s) Ã©lÃ©ment(s)
2. Les pousser vers la pile B
3. Trier les Ã©lÃ©ments restants dans A
4. RÃ©cupÃ©rer depuis B dans le bon ordre

Exemple avec [4, 2, 5, 1, 3] :
â”Œâ”€ Pile A â”€â”    â”Œâ”€ Pile B â”€â”
â”‚    4     â”‚    â”‚         â”‚
â”‚    2     â”‚    â”‚         â”‚
â”‚    5     â”‚    â”‚         â”‚
â”‚    1     â”‚    â”‚         â”‚  
â”‚    3     â”‚    â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰tape 1: Pousser les 2 plus petits (1 et 2) vers B
â”Œâ”€ Pile A â”€â”    â”Œâ”€ Pile B â”€â”
â”‚    4     â”‚    â”‚    2     â”‚  â† (en dernier)
â”‚    5     â”‚    â”‚    1     â”‚  â† (en premier)
â”‚    3     â”‚    â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰tape 2: Trier A [4, 5, 3] â†’ [3, 4, 5]
Ã‰tape 3: RÃ©cupÃ©rer B â†’ [1, 2, 3, 4, 5] âœ…

================================================================================
7. ALGORITHME GRANDES LISTES (> 5 Ã©lÃ©ments)
================================================================================

ğŸ§® MÃ‰THODE PAR CHUNKS (TURK ALGORITHM) :

Ã‰TAPE 1 - ATTRIBUTION D'INDEX :
-------------------------------
Pour [5, 2, 8, 1, 9, 3, 7] :
Assigner l'index = position dans le tri final

5 â†’ index 4 (5Ã¨me plus petit)
2 â†’ index 1 (2Ã¨me plus petit)
8 â†’ index 6 (6Ã¨me plus petit)
1 â†’ index 0 (1er plus petit)
9 â†’ index 7 (7Ã¨me plus petit)
3 â†’ index 2 (3Ã¨me plus petit)
7 â†’ index 5 (5Ã¨me plus petit)

Ã‰TAPE 2 - DIVISION EN CHUNKS :
------------------------------
Pour 100 Ã©lÃ©ments â†’ 5 chunks de ~20 Ã©lÃ©ments
Pour 500 Ã©lÃ©ments â†’ 11 chunks de ~45 Ã©lÃ©ments

Chunk 0: index 0-19
Chunk 1: index 20-39
Chunk 2: index 40-59
etc.

Ã‰TAPE 3 - ENVOI VERS PILE B :
-----------------------------
Pousser les Ã©lÃ©ments vers B chunk par chunk :

â”Œâ”€â”€â”€ Pile A â”€â”€â”€â”    â”Œâ”€â”€â”€ Pile B â”€â”€â”€â”
â”‚ (gros nums)  â”‚    â”‚   chunk 0    â”‚ â† plus petits
â”‚     ...      â”‚    â”‚   chunk 1    â”‚
â”‚     ...      â”‚    â”‚   chunk 2    â”‚
â”‚  (3 derniers)â”‚    â”‚     ...      â”‚ â† plus grands
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰TAPE 4 - CALCUL DES COÃ›TS :
----------------------------
Pour chaque Ã©lÃ©ment dans B, calculer :
- CoÃ»t pour le mettre en haut de B
- CoÃ»t pour positionner sa cible en haut de A
- CoÃ»t total = coÃ»t_A + coÃ»t_B

Ã‰TAPE 5 - RETOUR OPTIMISÃ‰ :
---------------------------
1. Choisir l'Ã©lÃ©ment avec le coÃ»t minimal
2. ExÃ©cuter les mouvements
3. Pousser vers A
4. RÃ©pÃ©ter jusqu'Ã  B vide

Ã‰TAPE 6 - ROTATION FINALE :
---------------------------
S'assurer que le plus petit Ã©lÃ©ment est en haut de A.

================================================================================
8. EXEMPLE COMPLET - VISUALISATION
================================================================================

Input: [5, 2, 8, 1, 9]

PHASE 1 - PARSING :
------------------
âœ… Validation : tous les nombres sont valides
âœ… Pas de doublons
âœ… Construction des stacks

Stack A: [5, 2, 8, 1, 9]    Stack B: []

PHASE 2 - ALGORITHME (5 Ã©lÃ©ments) :
-----------------------------------
1. Pousser les 2 plus petits vers B :
   - Minimum = 1 â†’ pb â†’ Stack B: [1]
   - Minimum = 2 â†’ pb â†’ Stack B: [2, 1]
   
   Stack A: [5, 8, 9]    Stack B: [2, 1]

2. Trier les 3 restants dans A :
   - sort_three([5, 8, 9]) â†’ dÃ©jÃ  triÃ© !
   
   Stack A: [5, 8, 9]    Stack B: [2, 1]

3. RÃ©cupÃ©rer depuis B :
   - pa â†’ Stack A: [2, 5, 8, 9]    Stack B: [1]
   - pa â†’ Stack A: [1, 2, 5, 8, 9]    Stack B: []

RÃ‰SULTAT FINAL : [1, 2, 5, 8, 9] âœ…

================================================================================
9. AVANTAGES DE CETTE APPROCHE
================================================================================

ğŸš€ PERFORMANCE :
- AccÃ¨s O(1) aux extrÃ©mitÃ©s des piles
- Pas de recherche linÃ©aire pour les opÃ©rations de base
- Algorithmes optimisÃ©s selon la taille

ğŸ¯ LISIBILITÃ‰ :
- SÃ©paration claire entre structure de donnÃ©es et algorithmes
- Code modulaire et maintenable

ğŸ”§ FLEXIBILITÃ‰ :
- Facile d'ajouter de nouvelles opÃ©rations
- PossibilitÃ© d'optimiser les algorithmes indÃ©pendamment

================================================================================
10. RÃ‰SUMÃ‰ FINAL
================================================================================

ğŸ—ï¸ ARCHITECTURE :
- t_node = Un livre dans une bibliothÃ¨que
- t_stack = Le catalogue qui sait oÃ¹ est le premier/dernier livre et combien il y en a

ğŸ§  ALGORITHME :
- Petites listes â†’ Solutions directes optimisÃ©es
- Grandes listes â†’ Division en chunks + calcul de coÃ»ts

ğŸ¯ OBJECTIF :
- Trier avec le minimum de mouvements possible
- Respecter les contraintes de complexitÃ© de 42

================================================================================

Ce systÃ¨me vous permet de gÃ©rer efficacement les deux piles et d'implÃ©menter
des algorithmes de tri sophistiquÃ©s tout en gardant des performances optimales !

================================================================================
